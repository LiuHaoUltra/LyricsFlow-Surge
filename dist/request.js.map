{"version":3,"file":"request.js","sources":["./src/request.ts","./src/utils/env.ts","./src/utils/logger.ts"],"sourcesContent":["import { env } from './utils/env';\r\nimport { logger } from './utils/logger';\r\n\r\n// Key prefix for storing metadata in persistent store\r\nconst META_KEY_PREFIX = 'spotify_meta_';\r\n\r\nasync function handleRequest() {\r\n    const url = env.request.url;\r\n    logger.debug(`[Request] Intercepted: ${url}`);\r\n\r\n    if (url.includes('/color-lyrics/v2/track/')) {\r\n        try {\r\n            // 1. Extract Track ID\r\n            // URL format: .../track/{trackId}?....\r\n            // We can split by '/' and find the segment after 'track'\r\n            const parts = url.split('/');\r\n            const trackIndex = parts.indexOf('track');\r\n            let trackId = '';\r\n            if (trackIndex !== -1 && parts[trackIndex + 1]) {\r\n                // Remove query params if any\r\n                trackId = parts[trackIndex + 1].split('?')[0];\r\n            }\r\n\r\n            if (trackId) {\r\n                logger.info(`[Request] Found Track ID: ${trackId}`);\r\n                await fetchAndCacheMetadata(trackId);\r\n            } else {\r\n                logger.warn(`[Request] Could not extract Track ID from URL: ${url}`);\r\n            }\r\n\r\n        } catch (err) {\r\n            logger.error(`[Request] Error processing request: ${err}`);\r\n        }\r\n    }\r\n\r\n    // Always release the request\r\n    env.done({});\r\n}\r\n\r\nasync function fetchAndCacheMetadata(trackId: string) {\r\n    // 2. Construct Metadata Request\r\n    // Using the same Authorization header from the original request\r\n    const headers = env.request.headers || {};\r\n    const authHeader = headers['Authorization'] || headers['authorization'];\r\n\r\n    if (!authHeader) {\r\n        logger.warn(`[Request] No Authorization header found. Cannot fetch metadata.`);\r\n        return;\r\n    }\r\n\r\n    const metaUrl = `https://api.spotify.com/v1/tracks?ids=${trackId}`;\r\n\r\n    try {\r\n        const response = await env.fetch({\r\n            url: metaUrl,\r\n            method: 'GET',\r\n            headers: {\r\n                'Authorization': authHeader,\r\n                'Accept': 'application/json'\r\n            }\r\n        });\r\n\r\n        if (response.status === 200 && response.body) {\r\n            const data = typeof response.body === 'string' ? JSON.parse(response.body) : response.body;\r\n            if (data.tracks && data.tracks.length > 0) {\r\n                const track = data.tracks[0];\r\n                const meta = {\r\n                    trackName: track.name,\r\n                    artist: track.artists ? track.artists.map((a: any) => a.name).join(', ') : 'Unknown',\r\n                    album: track.album ? track.album.name : 'Unknown',\r\n                    duration: track.duration_ms\r\n                };\r\n\r\n                // 3. Store in Persistent Store\r\n                const key = `${META_KEY_PREFIX}${trackId}`;\r\n                env.setStorage(key, JSON.stringify(meta));\r\n                logger.info(`[Request] Cached metadata for ${trackId}: ${meta.trackName}`);\r\n            }\r\n        } else {\r\n            logger.warn(`[Request] Metadata fetch failed: ${response.status}`);\r\n        }\r\n    } catch (err) {\r\n        logger.error(`[Request] Metadata fetch error: ${err}`);\r\n    }\r\n}\r\n\r\n// Global execution\r\nhandleRequest().catch(err => {\r\n    logger.error(\"Global Request Handler Error:\", err);\r\n    env.done({});\r\n});\r\n","/**\r\n * Environment Adapter for Surge\r\n * Handles HTTP requests, persistence, and script completion.\r\n */\r\n\r\nexport interface HelperRequestOpts {\r\n    url: string;\r\n    method?: string; // GET, POST, etc.\r\n    headers?: Record<string, string>;\r\n    body?: string | Uint8Array;\r\n    timeout?: number;\r\n    binary?: boolean; // If true, response body is expected to be binary (Uint8Array/Buffer)\r\n}\r\n\r\nexport class Env {\r\n    private name: string;\r\n    private isSurge: boolean;\r\n\r\n    constructor(name: string) {\r\n        this.name = name;\r\n        this.isSurge = typeof $httpClient !== 'undefined';\r\n    }\r\n\r\n    get args(): string {\r\n        return typeof $argument !== 'undefined' ? $argument : '';\r\n    }\r\n\r\n    get request(): any {\r\n        return typeof $request !== 'undefined' ? $request : { url: '', headers: {} };\r\n    }\r\n\r\n    /**\r\n     * Sends an HTTP request.\r\n     */\r\n    async fetch(opts: HelperRequestOpts): Promise<any> {\r\n        // Normalize method\r\n        const method = (opts.method || 'GET').toUpperCase();\r\n\r\n        // Prepare options for Surge\r\n        const requestOptions: any = {\r\n            url: opts.url,\r\n            method: method,\r\n            headers: opts.headers || {},\r\n            body: opts.body,\r\n            timeout: opts.timeout ? opts.timeout / 1000 : undefined, // Surge timeout is in seconds? usually defaults. \r\n        };\r\n\r\n        if (this.isSurge) {\r\n            if (opts.binary) {\r\n                // In Surge, for binary response, usually no special flag in request opts \r\n                // but $httpClient callback receives 'data' which can be binary if headers say so?\r\n                // Actually, $httpClient usually returns string or object. \r\n                // For binary, we might need to check how Surge handles it. \r\n                // usually it's automatic or we rely on 'node-buffer' polyfill if bundled.\r\n                // But for response, Surge passes `data`.\r\n            }\r\n\r\n            return new Promise((resolve, reject) => {\r\n                $httpClient[method.toLowerCase()](requestOptions, (error: any, response: any, data: any) => {\r\n                    if (error) {\r\n                        reject(error);\r\n                    } else {\r\n                        resolve({\r\n                            status: response.status || 200,\r\n                            headers: response.headers,\r\n                            body: data, // string or object or whatever Surge returns\r\n                        });\r\n                    }\r\n                });\r\n            });\r\n        } else {\r\n            // Fallback for Node/Testing (using global fetch if available)\r\n            return Promise.resolve({ error: \"Not in Surge environment\" });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Writes to persistent storage.\r\n     */\r\n    setStorage(key: string, value: string): void {\r\n        if (this.isSurge) {\r\n            $persistentStore.write(value, key);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Reads from persistent storage.\r\n     */\r\n    getStorage(key: string): string | null {\r\n        if (this.isSurge) {\r\n            return $persistentStore.read(key);\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Sends a system notification.\r\n     */\r\n    msg(title: string, subtitle: string, body: string): void {\r\n        if (this.isSurge) {\r\n            $notification.post(title, subtitle, body);\r\n        } else {\r\n            console.log(`[MSG] ${title} - ${subtitle}: ${body}`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Completes the script execution.\r\n     */\r\n    done(value: any = {}): void {\r\n        if (this.isSurge) {\r\n            $done(value);\r\n        }\r\n    }\r\n}\r\n\r\n// Global types for Surge (to avoid TS errors)\r\ndeclare const $httpClient: any;\r\ndeclare const $persistentStore: any;\r\ndeclare const $notification: any;\r\ndeclare const $done: any;\r\ndeclare const $argument: string;\r\ndeclare const $request: any;\r\n\r\nexport const env = new Env('LyricsFlow');\r\n","export enum LogLevel {\r\n    OFF = 0,\r\n    ERROR = 1,\r\n    WARN = 2,\r\n    INFO = 3,\r\n    DEBUG = 4,\r\n}\r\n\r\nexport class Logger {\r\n    private level: LogLevel;\r\n    private prefix: string;\r\n\r\n    constructor(level: string | LogLevel = LogLevel.INFO, prefix: string = '') {\r\n        this.level = typeof level === 'string' ? this.parseLevel(level) : level;\r\n        this.prefix = prefix;\r\n    }\r\n\r\n    public setLevel(level: LogLevel) {\r\n        this.level = level;\r\n    }\r\n\r\n    private parseLevel(level: string): LogLevel {\r\n        switch (level.toUpperCase()) {\r\n            case 'OFF': return LogLevel.OFF;\r\n            case 'ERROR': return LogLevel.ERROR;\r\n            case 'WARN': return LogLevel.WARN;\r\n            case 'INFO': return LogLevel.INFO;\r\n            case 'DEBUG': return LogLevel.DEBUG;\r\n            default: return LogLevel.INFO;\r\n        }\r\n    }\r\n\r\n    private format(level: string, message: string, ...args: any[]): string {\r\n        const timestamp = new Date().toISOString().split('T')[1].slice(0, -1);\r\n        return `[${timestamp}] [${level}] ${this.prefix}${message}`;\r\n    }\r\n\r\n    error(message: string, ...args: any[]): void {\r\n        if (this.level >= LogLevel.ERROR) {\r\n            console.log(this.format('ERROR', message), ...args);\r\n        }\r\n    }\r\n\r\n    warn(message: string, ...args: any[]): void {\r\n        if (this.level >= LogLevel.WARN) {\r\n            console.log(this.format('WARN', message), ...args);\r\n        }\r\n    }\r\n\r\n    info(message: string, ...args: any[]): void {\r\n        if (this.level >= LogLevel.INFO) {\r\n            console.log(this.format('INFO', message), ...args);\r\n        }\r\n    }\r\n\r\n    debug(message: string, ...args: any[]): void {\r\n        if (this.level >= LogLevel.DEBUG) {\r\n            console.log(this.format('DEBUG', message), ...args);\r\n        }\r\n    }\r\n}\r\n\r\nexport const logger = new Logger(); // Default instance\r\n"],"names":["url","parts","trackIndex","trackId","err","env","logger","includes","split","indexOf","fetchAndCacheMetadata","headers","authHeader","metaUrl","response","data","track","meta","key","method","status","body","JSON","parse","tracks","length","trackName","name","artist","artists","map","a","join","album","duration","duration_ms","stringify","handleRequest","catch","Env","isSurge","$httpClient","$argument","$request","opts","requestOptions","toUpperCase","timeout","undefined","binary","Promise","resolve","reject","toLowerCase","error","value","$persistentStore","write","read","title","subtitle","$notification","post","console","log","$done","LogLevel","Logger","level","prefix","parseLevel","message","args","timestamp","Date","toISOString","slice","format"],"mappings":"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"}